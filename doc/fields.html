<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>fields.html</title>

</head>

<body>

<h1>Overview</h1>

<p>This section refers to the <strong>models</strong> key in the general <em>config</em> structure below:</p>

<pre><code>{
    "storage": {
        "type": "storage type here",
        "spec": "storage spec here"
    },
    "models": {
        "model_number_1": {
            "model": {
                "field_1": {
                    "details": "here"
                },
                "field_2": {
                    "details": "here"
                }
            }
        },
        "model_number_2": {
            "...": "..."
        }
    }
}
</code></pre>

<h2>High Level Details</h2>

<ul>
<li><p>Each key top level key within the <em>models</em> object (seen above) corresponds to a table in the storage layer. The format and constraints of this name are enforced by the underlying storage.</p></li>
<li><p>Each <em>table</em> has a <em>model</em> key with an object of <em>fields</em>.</p></li>
<li><p>Each top level key within the <em>model</em> object (see above) corresponds to a column in that <em>table</em>. The format and constraints of this name are enforced by the underlying storage.</p></li>
<li><p>The details within the <em>field</em> object are discussed below. In general, they determine how that column is generated for each row.</p></li>
</ul>

<h2>Field Details</h2>

<h3>Field Types</h3>

<p>This tool has several internal field types. Each field type is specified in the field config like so:</p>

<pre><code>"field_1": {
    "type": "integer",
    "more": "details
}
</code></pre>

<p>This tool normalizes the provided field type and in turn, each storage layer normalizes the field type for it's purposes. A mapping of all supported inputs -> normalized types is provided below:</p>

<p><em>Note: Normalized types are the top level, possible config inputs are indented</em></p>

<ul>
<li>integer
<ul>
<li>integer</li>
<li>int</li>
</ul></li>
<li>text (pre-specified lengths are currently ignored)
<ul>
<li>text</li>
<li>string</li>
<li>var</li>
<li>var (256)</li>
<li>varchar </li>
<li>varchar (256)</li>
</ul></li>
<li>real
<ul>
<li>real</li>
<li>float</li>
</ul></li>
<li>double-precision
<ul>
<li>double-precision</li>
<li>double</li>
</ul></li>
<li>bigint
<ul>
<li>bigint</li>
<li>biginteger</li>
</ul></li>
<li>date
<ul>
<li>date</li>
</ul></li>
<li>timestamp-with-time-zone
<ul>
<li>timestamp with time zone</li>
<li>timestamp</li>
<li>datetime</li>
</ul></li>
<li>boolean
<ul>
<li>boolean</li>
<li>bool</li>
</ul></li>
</ul>

<p>There is one special field type, <em>association</em>. If a field is a foreign key to another table being generated, you specify it's type as <em>association</em> and the tool will determine the appropriate field type from that model's config.</p>

<h3>Master Field</h3>

<p>Exactly <strong>ONE</strong> field per model must have a "master" object that controls how the table as a whole is generated. There are currently three options here:</p>

<ol>
<li><p>Generated a fixed number of rows</p></li>
<li><p>Generate 0-N rows in this table <em>for each</em> row of another table in <em>this config</em>.</p></li>
<li><p>Generate a row in this table <em>for each</em> row of a provided "SQL query" within the database (can join multiple tables).</p></li>
</ol>

<h4>Fixed Number of Rows</h4>

<p>Within a field (consider "field_1" above), you would provide a key/value as so:</p>

<pre><code>"master": {
    "count": 3000
}
</code></pre>

<p>This would generate 3000 rows for that table. 3000 can be changed to any integer.</p>

<h4>Generate 0-N rows from a table in this config</h4>

<p>Within a field (consider "field_1" above), you would provide a key/value as so:</p>

<pre><code>"master": {
    "model": "model_number_2"
}
</code></pre>

<p>The above config reads "For each row of model_number_2 that is created, create a row in this table. The field containing </p>

<p>This is useful, but breaks down quickly for many datasets that don't have a 1:1 mapping of rows between tables. Things become more interesting when you add in additional keys next to "model".</p>

<ul>
<li>quantity</li>
<li>probability</li>
<li>foreach</li>
</ul>

<h5>Quantity</h5>

<p>This lets you build 1:Many associations. The <code>quantity</code> value is any "Field Value Config" (see below) that can return an integer.</p>

<p>Here's an example for creating between 1 and 10 rows in this tab for each row of the <em>mode_number_1</em> table.</p>

<pre><code>"master": {
    "model": "model_number_1",
    "quantity": {
        "type": "range",
        "properties": {
            "min": 1,
            "max": 11
        }
    }
}
</code></pre>

<p>You can read more about the details of various "Field Value Congfig's" below.</p>

<p><code>quantity</code> can be used by itself, or in conjunction with <code>probability</code>. A quantity of <code>0</code> is valid and will result in no rows being created.</p>

<h5>Probability</h5>

<p>This lets you determine a likelyhood that <em>any</em> rows in this table will be created. This defaults to 1 (for 100%).</p>

<p>Here's an example that gives a 70% chance that we we create a row(s) in this table for the input row.</p>

<pre><code>"master": {
    "model": "model_number_1",
    "probability": 0.7
}
</code></pre>

<p><code>probability</code> can be used by itself, or in conjuction with <code>quantity</code>. A <code>probability</code> of <code>0</code> is the same as a <code>quantity</code> of <code>0</code> in that no rows in this table will be created.</p>

<h5>Foreach</h5>

<p>This lets you create a row(s) in table <code>model_number_1</code> not just for each row in <code>model_number_1</code>, but for each permutation of rows in multiple tables.</p>

<p>Let's say you have a <code>campaigns</code> table and a <code>list_members</code> table. For each campaign sent to a list, you want a single row in the <code>email</code> table. Here's what that might look like:</p>

<pre><code>"master": {
    "model": "campaigns",
    "foreach": {
        "model": "list_members"
    }
}
</code></pre>

<p>The <code>foreach</code> block can also have a <code>filter</code> key/value. Using references (explained in detail below) you can specify which permutations to include/exclude. Here's an example of only including rows of <code>list_members</code> where the column <code>age</code> is greater than 18.</p>

<pre><code>"master": {
    "model": "campaigns",
    "foreach": {
        "model": "list_members",
        "filter": "$list_members.age &gt; 18"
    }
}
</code></pre>

<p>The <code>foreach</code> value can optionally be an array of objects to create a permutation between more than 2 tables. Be careful though, permutations with multiple large tables can get very large very fast!</p>

<p><code>foreach</code> can be used with both <code>quantity</code> and <code>probability</code>.</p>

<h4>Generate a row for each row in a SQL query</h4>

<p>If you have a pre-existing data set that you'd like to extend with more tables, you can provide the <code>master</code> block with a sql query to "seed" this table with data. Here's an example of building an <code>orders</code> table from two existing "sub_tables" that had been generated previously.</p>

<pre><code>"master": {
    "type": "remote-query",
    "model": "dummy_name_for_query",
    "query": "select * from (select customer, \"type\", campaign, createdat from direct_orders UNION ALL select customer, \"type\", campaign, createdat from email_orders) as temp order by createdat;"
}
</code></pre>

<p>In this scenario, we'll create a row for each return row from the query, and each "Field Value Config" (described below) will have access to the values of these returned rows.</p>

<h3>Field Values</h3>

<p>[Details can be found here][field_values.md]</p>

</body>
</html>
